/*
 * This file has been automatically generated by Soupply and released under the MIT license.
 * Generated from test0
 */
module soupply.test0.metadata;

import packetmaker;
import packetmaker.maker : EndianType, writeLength;

import soupply.util : Vector;

import soupply.test0.packet : Test0Packet;
static import soupply.test0.types;

enum MetadataType : uint
{
    BYTE = 0,
}

class MetadataValue : Test0Packet
{

    @Var uint id;
    @Var uint type;

    this(uint id, uint type) pure nothrow @safe @nogc
    {
        this.id = id;
        this.type = type;
    }

    mixin Make;

}

class MetadataValue0 : MetadataValue
{

    byte value;

    this(uint id, byte value) pure nothrow @safe @nogc
    {
        super(id, 0);
        this.value = value;
    }

    mixin Make;

}

struct Metadata
{

    private MetadataValue[uint] _store;
    private bool _cached = false;
    private ubyte[] _cache;

    void encodeBody(InputBuffer buffer)
    {
        if(!_cached)
        {
            InputBuffer _buffer = new InputBuffer();
            writeLength!(EndianType.var, uint)(_buffer, _store.length);
            foreach(value ; _store) value.encodeBody(_buffer);
            _cached = true;
            _cache = _buffer.data;
        }
        buffer.writeBytes(_cache);
    }

    void decodeBody(OutputBuffer buffer)
    {
        assert(0, `Cannot decode Metadata`);
    }

}
