/*
 * This file has been automatically generated by Soupply and released under the MIT license.
 * Generated from data/test0.xml
 */
module soupply.test0.protocol.test;

static import std.conv;
import std.typetuple : TypeTuple;
import packetmaker;

import soupply.util : Vector, UUID;
import soupply.test0.metadata : Metadata;
import soupply.test0.packet : Test0Packet;

static import soupply.test0.types;

alias Packets = TypeTuple!(TestInt, TestFloat, TestArray);

class TestInt : Test0Packet
{

    enum ubyte ID = 0;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["a", "b", "c", "d", "e"];

    byte a;
    ushort b;
    @LittleEndian long c;
    @Var short d;
    @Var uint e;

    this() pure nothrow @safe @nogc {}

    this(byte a, ushort b=ushort.init, long c=long.init, short d=short.init, uint e=uint.init) pure nothrow @safe @nogc
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        TestInt ret = new TestInt();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "TestInt(a: " ~ std.conv.to!string(this.a) ~ ", b: " ~ std.conv.to!string(this.b) ~ ", c: " ~ std.conv.to!string(this.c) ~ ", d: " ~ std.conv.to!string(this.d) ~ ", e: " ~ std.conv.to!string(this.e) ~ ")";
    }

    unittest
    {

        import std.conv : to;

        TestInt packet = new TestInt();

        packet.d = 10;
        packet.e = 500;
        packet.b = 300;
        packet.c = 1;
        packet.a = -10;
        auto result = packet.autoEncode();
        assert(result == [0, 246, 1, 44, 1, 0, 0, 0, 0, 0, 0, 0, 20, 244, 3], `test0.test.test-int expected [0, 246, 1, 44, 1, 0, 0, 0, 0, 0, 0, 0, 20, 244, 3] but got ` ~ result.to!string);

        packet.autoDecode([0, 246, 1, 44, 1, 0, 0, 0, 0, 0, 0, 0, 20, 244, 3]);
        assert(packet.d == 10, `test0.test.test-int.d expected 10 but got ` ~ packet.d.to!string);
        assert(packet.e == 500, `test0.test.test-int.e expected 500 but got ` ~ packet.e.to!string);
        assert(packet.b == 300, `test0.test.test-int.b expected 300 but got ` ~ packet.b.to!string);
        assert(packet.c == 1, `test0.test.test-int.c expected 1 but got ` ~ packet.c.to!string);
        assert(packet.a == -10, `test0.test.test-int.a expected -10 but got ` ~ packet.a.to!string);

    }

}

class TestFloat : Test0Packet
{

    enum ubyte ID = 1;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["a", "b", "c"];

    float a;
    double b;
    @LittleEndian float c;

    this() pure nothrow @safe @nogc {}

    this(float a, double b=double.init, float c=float.init) pure nothrow @safe @nogc
    {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        TestFloat ret = new TestFloat();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "TestFloat(a: " ~ std.conv.to!string(this.a) ~ ", b: " ~ std.conv.to!string(this.b) ~ ", c: " ~ std.conv.to!string(this.c) ~ ")";
    }

    unittest
    {

        import std.conv : to;

        TestFloat packet = new TestFloat();

        packet.b = 312;
        packet.c = -44;
        packet.a = 1;
        auto result = packet.autoEncode();
        assert(result == [1, 63, 128, 0, 0, 64, 115, 128, 0, 0, 0, 0, 0, 0, 0, 48, 194], `test0.test.test-float expected [1, 63, 128, 0, 0, 64, 115, 128, 0, 0, 0, 0, 0, 0, 0, 48, 194] but got ` ~ result.to!string);

        packet.autoDecode([1, 63, 128, 0, 0, 64, 115, 128, 0, 0, 0, 0, 0, 0, 0, 48, 194]);
        assert(packet.b == 312, `test0.test.test-float.b expected 312 but got ` ~ packet.b.to!string);
        assert(packet.c == -44, `test0.test.test-float.c expected -44 but got ` ~ packet.c.to!string);
        assert(packet.a == 1, `test0.test.test-float.a expected 1 but got ` ~ packet.a.to!string);

    }

}

class TestArray : Test0Packet
{

    enum ubyte ID = 2;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["a", "b", "c", "d"];

    ubyte[] a;
    string b;
    @Length!int short[] c;
    @Var uint[] d;

    this() pure nothrow @safe @nogc {}

    this(ubyte[] a, string b=string.init, short[] c=(short[]).init, uint[] d=(uint[]).init) pure nothrow @safe @nogc
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        TestArray ret = new TestArray();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "TestArray(a: " ~ std.conv.to!string(this.a) ~ ", b: " ~ std.conv.to!string(this.b) ~ ", c: " ~ std.conv.to!string(this.c) ~ ", d: " ~ std.conv.to!string(this.d) ~ ")";
    }

    unittest
    {

        import std.conv : to;

        TestArray packet = new TestArray();

        packet.d = [0, 400];
        packet.b = "test";
        packet.c = [-1, 0, 1];
        packet.a = [3, 2];
        auto result = packet.autoEncode();
        assert(result == [2, 2, 3, 2, 4, 116, 101, 115, 116, 0, 3, 255, 255, 0, 0, 0, 1, 2, 0, 144, 3], `test0.test.test-array expected [2, 2, 3, 2, 4, 116, 101, 115, 116, 0, 3, 255, 255, 0, 0, 0, 1, 2, 0, 144, 3] but got ` ~ result.to!string);

        packet.autoDecode([2, 2, 3, 2, 4, 116, 101, 115, 116, 0, 3, 255, 255, 0, 0, 0, 1, 2, 0, 144, 3]);
        assert(packet.d == [0, 400], `test0.test.test-array.d expected [0,400] but got ` ~ packet.d.to!string);
        assert(packet.b == "test", `test0.test.test-array.b expected "test" but got ` ~ packet.b.to!string);
        assert(packet.c == [-1, 0, 1], `test0.test.test-array.c expected [-1,0,1] but got ` ~ packet.c.to!string);
        assert(packet.a == [3, 2], `test0.test.test-array.a expected [3,2] but got ` ~ packet.a.to!string);

    }

}
