/*
 * This file has been automatically generated by Soupply and released under the MIT license.
 * Generated from data/pocket100.xml
 */
module soupply.pocket100.protocol.play;

static import std.conv;
import std.typetuple : TypeTuple;
import packetmaker;

import soupply.util : Vector, UUID;
import soupply.pocket100.metadata : Metadata;
import soupply.pocket100.packet : Pocket100Packet;

static import soupply.pocket100.types;

alias Packets = TypeTuple!(Login, PlayStatus, ServerToClientHandshake, ClientToServerHandshake, Disconnect, Batch, ResourcePacksInfo, ResourcePacksStackPacket, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, RemoveBlock, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, MobEquipment, MobArmorEquipment, Interact, UseItem, PlayerAction, PlayerFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, DropItem, InventoryAction, ContainerOpen, ContainerClose, ContainerSetSlot, ContainerSetData, ContainerSetContent, CraftingData, CraftingEvent, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCommandsEnabled, SetDifficulty, ChangeDimension, SetPlayerGameType, PlayerList, TelemetryEvent, SpawnExperienceOrb, ClientboundMapItemData, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, ReplaceSelectedItem, GameRulesChanged, Camera, AddItem, BossEvent, ShowCredits, AvailableCommands, CommandStep, ResourcePackDataInfo, ResourcePackChunkData, ResourcePackChunkRequest);

class Login : Pocket100Packet
{

    enum ubyte ID = 1;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    // edition
    enum ubyte CLASSIC = 0;
    enum ubyte EDUCATION = 1;

    enum string[] __fields = ["protocol", "edition", "body_"];

    uint protocol;
    ubyte edition;
    ubyte[] body_;

    this() pure nothrow @safe @nogc {}

    this(uint protocol, ubyte edition=ubyte.init, ubyte[] body_=(ubyte[]).init) pure nothrow @safe @nogc
    {
        this.protocol = protocol;
        this.edition = edition;
        this.body_ = body_;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Login ret = new Login();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Login(protocol: " ~ std.conv.to!string(this.protocol) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", body_: " ~ std.conv.to!string(this.body_) ~ ")";
    }

}

class PlayStatus : Pocket100Packet
{

    enum ubyte ID = 2;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // status
    enum uint OK = 0;
    enum uint OUTDATED_CLIENT = 1;
    enum uint OUTDATED_SERVER = 2;
    enum uint SPAWNED = 3;
    enum uint INVALID_TENANT = 4;
    enum uint EDITION_MISMATCH = 5;

    enum string[] __fields = ["status"];

    uint status;

    this() pure nothrow @safe @nogc {}

    this(uint status) pure nothrow @safe @nogc
    {
        this.status = status;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        PlayStatus ret = new PlayStatus();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "PlayStatus(status: " ~ std.conv.to!string(this.status) ~ ")";
    }

}

class ServerToClientHandshake : Pocket100Packet
{

    enum ubyte ID = 3;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["serverPublicKey", "token"];

    string serverPublicKey;
    ubyte[] token;

    this() pure nothrow @safe @nogc {}

    this(string serverPublicKey, ubyte[] token=(ubyte[]).init) pure nothrow @safe @nogc
    {
        this.serverPublicKey = serverPublicKey;
        this.token = token;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ServerToClientHandshake ret = new ServerToClientHandshake();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ServerToClientHandshake(serverPublicKey: " ~ std.conv.to!string(this.serverPublicKey) ~ ", token: " ~ std.conv.to!string(this.token) ~ ")";
    }

}

class ClientToServerHandshake : Pocket100Packet
{

    enum ubyte ID = 4;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = [];

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ClientToServerHandshake ret = new ClientToServerHandshake();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ClientToServerHandshake()";
    }

}

class Disconnect : Pocket100Packet
{

    enum ubyte ID = 5;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["hideDisconnectionScreen", "message"];

    bool hideDisconnectionScreen;
    @Condition("hideDisconnectionScreen==false") string message;

    this() pure nothrow @safe @nogc {}

    this(bool hideDisconnectionScreen, string message=string.init) pure nothrow @safe @nogc
    {
        this.hideDisconnectionScreen = hideDisconnectionScreen;
        this.message = message;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Disconnect ret = new Disconnect();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Disconnect(hideDisconnectionScreen: " ~ std.conv.to!string(this.hideDisconnectionScreen) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
    }

}

class Batch : Pocket100Packet
{

    enum ubyte ID = 6;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["data"];

    ubyte[] data;

    this() pure nothrow @safe @nogc {}

    this(ubyte[] data) pure nothrow @safe @nogc
    {
        this.data = data;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Batch ret = new Batch();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Batch(data: " ~ std.conv.to!string(this.data) ~ ")";
    }

}

class ResourcePacksInfo : Pocket100Packet
{

    enum ubyte ID = 7;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["mustAccept", "behaviourPacks", "resourcePacks"];

    bool mustAccept;
    @EndianLength!ushort(Endian.littleEndian) soupply.pocket100.types.PackWithSize[] behaviourPacks;
    @EndianLength!ushort(Endian.littleEndian) soupply.pocket100.types.PackWithSize[] resourcePacks;

    this() pure nothrow @safe @nogc {}

    this(bool mustAccept, soupply.pocket100.types.PackWithSize[] behaviourPacks=(soupply.pocket100.types.PackWithSize[]).init, soupply.pocket100.types.PackWithSize[] resourcePacks=(soupply.pocket100.types.PackWithSize[]).init) pure nothrow @safe @nogc
    {
        this.mustAccept = mustAccept;
        this.behaviourPacks = behaviourPacks;
        this.resourcePacks = resourcePacks;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePacksInfo ret = new ResourcePacksInfo();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePacksInfo(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
    }

}

class ResourcePacksStackPacket : Pocket100Packet
{

    enum ubyte ID = 8;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["mustAccept", "behaviourPacks", "resourcePacks"];

    bool mustAccept;
    @EndianLength!ushort(Endian.littleEndian) soupply.pocket100.types.Pack[] behaviourPacks;
    @EndianLength!ushort(Endian.littleEndian) soupply.pocket100.types.Pack[] resourcePacks;

    this() pure nothrow @safe @nogc {}

    this(bool mustAccept, soupply.pocket100.types.Pack[] behaviourPacks=(soupply.pocket100.types.Pack[]).init, soupply.pocket100.types.Pack[] resourcePacks=(soupply.pocket100.types.Pack[]).init) pure nothrow @safe @nogc
    {
        this.mustAccept = mustAccept;
        this.behaviourPacks = behaviourPacks;
        this.resourcePacks = resourcePacks;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePacksStackPacket ret = new ResourcePacksStackPacket();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePacksStackPacket(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
    }

}

class ResourcePackClientResponse : Pocket100Packet
{

    enum ubyte ID = 9;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    // status
    enum ubyte REFUSED = 1;
    enum ubyte SEND_PACKS = 2;
    enum ubyte HAVE_ALL_PACKS = 3;
    enum ubyte COMPLETED = 4;

    enum string[] __fields = ["status", "packIds"];

    ubyte status;
    @EndianLength!ushort(Endian.littleEndian) string[] packIds;

    this() pure nothrow @safe @nogc {}

    this(ubyte status, string[] packIds=(string[]).init) pure nothrow @safe @nogc
    {
        this.status = status;
        this.packIds = packIds;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePackClientResponse ret = new ResourcePackClientResponse();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePackClientResponse(status: " ~ std.conv.to!string(this.status) ~ ", packIds: " ~ std.conv.to!string(this.packIds) ~ ")";
    }

}

class Text : Pocket100Packet
{

    enum ubyte ID = 10;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["type"];

    ubyte type;

    this() pure nothrow @safe @nogc {}

    this(ubyte type) pure nothrow @safe @nogc
    {
        this.type = type;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Text ret = new Text();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Text(type: " ~ std.conv.to!string(this.type) ~ ")";
    }

    enum string variantField = "type";

    alias Variants = TypeTuple!(Raw, Chat, Translation, Popup, Tip, System, Whisper);

    class Raw : Pocket100Packet
    {

        enum typeof(type) TYPE = 0;

        enum string[] __fields = ["message"];

        string message;

        this() pure nothrow @safe @nogc {}

        this(string message) pure nothrow @safe @nogc
        {
            this.message = message;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Raw(message: " ~ std.conv.to!string(this.message) ~ ")";
        }

    }

    class Chat : Pocket100Packet
    {

        enum typeof(type) TYPE = 1;

        enum string[] __fields = ["sender", "message"];

        string sender;
        string message;

        this() pure nothrow @safe @nogc {}

        this(string sender, string message=string.init) pure nothrow @safe @nogc
        {
            this.sender = sender;
            this.message = message;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Chat(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
        }

    }

    class Translation : Pocket100Packet
    {

        enum typeof(type) TYPE = 2;

        enum string[] __fields = ["message", "parameters"];

        string message;
        string[] parameters;

        this() pure nothrow @safe @nogc {}

        this(string message, string[] parameters=(string[]).init) pure nothrow @safe @nogc
        {
            this.message = message;
            this.parameters = parameters;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Translation(message: " ~ std.conv.to!string(this.message) ~ ", parameters: " ~ std.conv.to!string(this.parameters) ~ ")";
        }

    }

    class Popup : Pocket100Packet
    {

        enum typeof(type) TYPE = 3;

        enum string[] __fields = ["title", "subtitle"];

        string title;
        string subtitle;

        this() pure nothrow @safe @nogc {}

        this(string title, string subtitle=string.init) pure nothrow @safe @nogc
        {
            this.title = title;
            this.subtitle = subtitle;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Popup(title: " ~ std.conv.to!string(this.title) ~ ", subtitle: " ~ std.conv.to!string(this.subtitle) ~ ")";
        }

    }

    class Tip : Pocket100Packet
    {

        enum typeof(type) TYPE = 4;

        enum string[] __fields = ["message"];

        string message;

        this() pure nothrow @safe @nogc {}

        this(string message) pure nothrow @safe @nogc
        {
            this.message = message;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Tip(message: " ~ std.conv.to!string(this.message) ~ ")";
        }

    }

    class System : Pocket100Packet
    {

        enum typeof(type) TYPE = 5;

        enum string[] __fields = ["message"];

        string message;

        this() pure nothrow @safe @nogc {}

        this(string message) pure nothrow @safe @nogc
        {
            this.message = message;
        }

        mixin Make;

        override string toString()
        {
            return "Text.System(message: " ~ std.conv.to!string(this.message) ~ ")";
        }

    }

    class Whisper : Pocket100Packet
    {

        enum typeof(type) TYPE = 6;

        enum string[] __fields = ["sender", "message"];

        string sender;
        string message;

        this() pure nothrow @safe @nogc {}

        this(string sender, string message=string.init) pure nothrow @safe @nogc
        {
            this.sender = sender;
            this.message = message;
        }

        mixin Make;

        override string toString()
        {
            return "Text.Whisper(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
        }

    }

}

class SetTime : Pocket100Packet
{

    enum ubyte ID = 11;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["time", "daylightCycle"];

    @Var int time;
    bool daylightCycle;

    this() pure nothrow @safe @nogc {}

    this(int time, bool daylightCycle=bool.init) pure nothrow @safe @nogc
    {
        this.time = time;
        this.daylightCycle = daylightCycle;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetTime ret = new SetTime();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetTime(time: " ~ std.conv.to!string(this.time) ~ ", daylightCycle: " ~ std.conv.to!string(this.daylightCycle) ~ ")";
    }

}

class StartGame : Pocket100Packet
{

    enum ubyte ID = 12;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // dimension
    enum int OVERWORLD = 0;
    enum int NETHER = 1;
    enum int END = 2;

    // generator
    enum int OLD = 0;
    enum int INFINITE = 1;
    enum int FLAT = 2;

    // world gamemode
    enum int SURVIVAL = 0;
    enum int CREATIVE = 1;

    // difficulty
    enum int PEACEFUL = 0;
    enum int EASY = 1;
    enum int NORMAL = 2;
    enum int HARD = 3;

    // edition
    enum ubyte CLASSIC = 0;
    enum ubyte EDUCATION = 1;

    enum string[] __fields = ["entityId", "runtimeId", "position", "yaw", "pitch", "seed", "dimension", "generator", "worldGamemode", "difficulty", "spawnPosition", "loadedInCreative", "time", "edition", "rainLevel", "lightningLevel", "commandsEnabled", "textureRequired", "levelId", "worldName"];

    @Var long entityId;
    @Var long runtimeId;
    Vector!(float, "xyz") position;
    float yaw;
    float pitch;
    @Var int seed;
    @Var int dimension;
    @Var int generator;
    @Var int worldGamemode;
    @Var int difficulty;
    @Var Vector!(int, "xyz") spawnPosition;
    bool loadedInCreative;
    @Var int time;
    ubyte edition;
    float rainLevel;
    float lightningLevel;
    bool commandsEnabled;
    bool textureRequired;
    string levelId;
    string worldName;

    this() pure nothrow @safe @nogc {}

    this(long entityId, long runtimeId=long.init, Vector!(float, "xyz") position=Vector!(float, "xyz").init, float yaw=float.init, float pitch=float.init, int seed=int.init, int dimension=int.init, int generator=int.init, int worldGamemode=int.init, int difficulty=int.init, Vector!(int, "xyz") spawnPosition=Vector!(int, "xyz").init, bool loadedInCreative=bool.init, int time=int.init, ubyte edition=ubyte.init, float rainLevel=float.init, float lightningLevel=float.init, bool commandsEnabled=bool.init, bool textureRequired=bool.init, string levelId=string.init, string worldName=string.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
        this.seed = seed;
        this.dimension = dimension;
        this.generator = generator;
        this.worldGamemode = worldGamemode;
        this.difficulty = difficulty;
        this.spawnPosition = spawnPosition;
        this.loadedInCreative = loadedInCreative;
        this.time = time;
        this.edition = edition;
        this.rainLevel = rainLevel;
        this.lightningLevel = lightningLevel;
        this.commandsEnabled = commandsEnabled;
        this.textureRequired = textureRequired;
        this.levelId = levelId;
        this.worldName = worldName;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        StartGame ret = new StartGame();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "StartGame(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", seed: " ~ std.conv.to!string(this.seed) ~ ", dimension: " ~ std.conv.to!string(this.dimension) ~ ", generator: " ~ std.conv.to!string(this.generator) ~ ", worldGamemode: " ~ std.conv.to!string(this.worldGamemode) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", spawnPosition: " ~ std.conv.to!string(this.spawnPosition) ~ ", loadedInCreative: " ~ std.conv.to!string(this.loadedInCreative) ~ ", time: " ~ std.conv.to!string(this.time) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", rainLevel: " ~ std.conv.to!string(this.rainLevel) ~ ", lightningLevel: " ~ std.conv.to!string(this.lightningLevel) ~ ", commandsEnabled: " ~ std.conv.to!string(this.commandsEnabled) ~ ", textureRequired: " ~ std.conv.to!string(this.textureRequired) ~ ", levelId: " ~ std.conv.to!string(this.levelId) ~ ", worldName: " ~ std.conv.to!string(this.worldName) ~ ")";
    }

}

class AddPlayer : Pocket100Packet
{

    enum ubyte ID = 13;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["uuid", "username", "entityId", "runtimeId", "position", "motion", "pitch", "headYaw", "yaw", "heldItem", "metadata"];

    UUID uuid;
    string username;
    @Var long entityId;
    @Var long runtimeId;
    Vector!(float, "xyz") position;
    Vector!(float, "xyz") motion;
    float pitch;
    float headYaw;
    float yaw;
    soupply.pocket100.types.Slot heldItem;
    Metadata metadata;

    this() pure nothrow @safe @nogc {}

    this(UUID uuid, string username=string.init, long entityId=long.init, long runtimeId=long.init, Vector!(float, "xyz") position=Vector!(float, "xyz").init, Vector!(float, "xyz") motion=Vector!(float, "xyz").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, soupply.pocket100.types.Slot heldItem=soupply.pocket100.types.Slot.init, Metadata metadata=Metadata.init) pure nothrow @safe @nogc
    {
        this.uuid = uuid;
        this.username = username;
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.position = position;
        this.motion = motion;
        this.pitch = pitch;
        this.headYaw = headYaw;
        this.yaw = yaw;
        this.heldItem = heldItem;
        this.metadata = metadata;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddPlayer ret = new AddPlayer();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddPlayer(uuid: " ~ std.conv.to!string(this.uuid) ~ ", username: " ~ std.conv.to!string(this.username) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", heldItem: " ~ std.conv.to!string(this.heldItem) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
    }

}

class AddEntity : Pocket100Packet
{

    enum ubyte ID = 14;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "runtimeId", "type", "position", "motion", "pitch", "yaw", "attributes", "metadata", "links"];

    @Var long entityId;
    @Var long runtimeId;
    @Var uint type;
    Vector!(float, "xyz") position;
    Vector!(float, "xyz") motion;
    float pitch;
    float yaw;
    soupply.pocket100.types.Attribute[] attributes;
    Metadata metadata;
    soupply.pocket100.types.Link[] links;

    this() pure nothrow @safe @nogc {}

    this(long entityId, long runtimeId=long.init, uint type=uint.init, Vector!(float, "xyz") position=Vector!(float, "xyz").init, Vector!(float, "xyz") motion=Vector!(float, "xyz").init, float pitch=float.init, float yaw=float.init, soupply.pocket100.types.Attribute[] attributes=(soupply.pocket100.types.Attribute[]).init, Metadata metadata=Metadata.init, soupply.pocket100.types.Link[] links=(soupply.pocket100.types.Link[]).init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.type = type;
        this.position = position;
        this.motion = motion;
        this.pitch = pitch;
        this.yaw = yaw;
        this.attributes = attributes;
        this.metadata = metadata;
        this.links = links;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddEntity ret = new AddEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ", links: " ~ std.conv.to!string(this.links) ~ ")";
    }

}

class RemoveEntity : Pocket100Packet
{

    enum ubyte ID = 15;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId"];

    @Var long entityId;

    this() pure nothrow @safe @nogc {}

    this(long entityId) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        RemoveEntity ret = new RemoveEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "RemoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
    }

}

class AddItemEntity : Pocket100Packet
{

    enum ubyte ID = 16;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "runtimeId", "item", "position", "motion"];

    @Var long entityId;
    @Var long runtimeId;
    soupply.pocket100.types.Slot item;
    Vector!(float, "xyz") position;
    Vector!(float, "xyz") motion;

    this() pure nothrow @safe @nogc {}

    this(long entityId, long runtimeId=long.init, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init, Vector!(float, "xyz") position=Vector!(float, "xyz").init, Vector!(float, "xyz") motion=Vector!(float, "xyz").init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.item = item;
        this.position = position;
        this.motion = motion;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddItemEntity ret = new AddItemEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddItemEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
    }

}

class AddHangingEntity : Pocket100Packet
{

    enum ubyte ID = 17;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "runtimeId", "position", "unknown3"];

    @Var long entityId;
    @Var long runtimeId;
    soupply.pocket100.types.BlockPosition position;
    @Var int unknown3;

    this() pure nothrow @safe @nogc {}

    this(long entityId, long runtimeId=long.init, soupply.pocket100.types.BlockPosition position=soupply.pocket100.types.BlockPosition.init, int unknown3=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.position = position;
        this.unknown3 = unknown3;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddHangingEntity ret = new AddHangingEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddHangingEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ")";
    }

}

class TakeItemEntity : Pocket100Packet
{

    enum ubyte ID = 18;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["collected", "collector"];

    @Var long collected;
    @Var long collector;

    this() pure nothrow @safe @nogc {}

    this(long collected, long collector=long.init) pure nothrow @safe @nogc
    {
        this.collected = collected;
        this.collector = collector;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        TakeItemEntity ret = new TakeItemEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "TakeItemEntity(collected: " ~ std.conv.to!string(this.collected) ~ ", collector: " ~ std.conv.to!string(this.collector) ~ ")";
    }

}

class MoveEntity : Pocket100Packet
{

    enum ubyte ID = 19;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "position", "pitch", "headYaw", "yaw"];

    @Var long entityId;
    Vector!(float, "xyz") position;
    ubyte pitch;
    ubyte headYaw;
    ubyte yaw;

    this() pure nothrow @safe @nogc {}

    this(long entityId, Vector!(float, "xyz") position=Vector!(float, "xyz").init, ubyte pitch=ubyte.init, ubyte headYaw=ubyte.init, ubyte yaw=ubyte.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.position = position;
        this.pitch = pitch;
        this.headYaw = headYaw;
        this.yaw = yaw;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MoveEntity ret = new MoveEntity();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ")";
    }

}

class MovePlayer : Pocket100Packet
{

    enum ubyte ID = 20;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // animation
    enum ubyte FULL = 0;
    enum ubyte NONE = 1;
    enum ubyte ROTATION = 2;

    enum string[] __fields = ["entityId", "position", "pitch", "headYaw", "yaw", "animation", "onGround"];

    @Var long entityId;
    Vector!(float, "xyz") position;
    float pitch;
    float headYaw;
    float yaw;
    ubyte animation;
    bool onGround;

    this() pure nothrow @safe @nogc {}

    this(long entityId, Vector!(float, "xyz") position=Vector!(float, "xyz").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, ubyte animation=ubyte.init, bool onGround=bool.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.position = position;
        this.pitch = pitch;
        this.headYaw = headYaw;
        this.yaw = yaw;
        this.animation = animation;
        this.onGround = onGround;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MovePlayer ret = new MovePlayer();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MovePlayer(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", animation: " ~ std.conv.to!string(this.animation) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
    }

}

class RiderJump : Pocket100Packet
{

    enum ubyte ID = 21;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["rider"];

    @Var long rider;

    this() pure nothrow @safe @nogc {}

    this(long rider) pure nothrow @safe @nogc
    {
        this.rider = rider;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        RiderJump ret = new RiderJump();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "RiderJump(rider: " ~ std.conv.to!string(this.rider) ~ ")";
    }

}

class RemoveBlock : Pocket100Packet
{

    enum ubyte ID = 22;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["position"];

    soupply.pocket100.types.BlockPosition position;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition position) pure nothrow @safe @nogc
    {
        this.position = position;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        RemoveBlock ret = new RemoveBlock();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "RemoveBlock(position: " ~ std.conv.to!string(this.position) ~ ")";
    }

}

class UpdateBlock : Pocket100Packet
{

    enum ubyte ID = 23;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // flags and meta
    enum uint NEIGHBORS = 1;
    enum uint NETWORK = 2;
    enum uint NO_GRAPHIC = 4;
    enum uint PRIORITY = 8;

    enum string[] __fields = ["position", "block", "flagsAndMeta"];

    soupply.pocket100.types.BlockPosition position;
    @Var uint block;
    @Var uint flagsAndMeta;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition position, uint block=uint.init, uint flagsAndMeta=uint.init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.block = block;
        this.flagsAndMeta = flagsAndMeta;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        UpdateBlock ret = new UpdateBlock();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "UpdateBlock(position: " ~ std.conv.to!string(this.position) ~ ", block: " ~ std.conv.to!string(this.block) ~ ", flagsAndMeta: " ~ std.conv.to!string(this.flagsAndMeta) ~ ")";
    }

}

class AddPainting : Pocket100Packet
{

    enum ubyte ID = 24;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "runtimeId", "position", "direction", "title"];

    @Var long entityId;
    @Var long runtimeId;
    soupply.pocket100.types.BlockPosition position;
    @Var int direction;
    string title;

    this() pure nothrow @safe @nogc {}

    this(long entityId, long runtimeId=long.init, soupply.pocket100.types.BlockPosition position=soupply.pocket100.types.BlockPosition.init, int direction=int.init, string title=string.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.runtimeId = runtimeId;
        this.position = position;
        this.direction = direction;
        this.title = title;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddPainting ret = new AddPainting();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddPainting(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ", title: " ~ std.conv.to!string(this.title) ~ ")";
    }

}

class Explode : Pocket100Packet
{

    enum ubyte ID = 25;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position", "radius", "destroyedBlocks"];

    Vector!(float, "xyz") position;
    float radius;
    soupply.pocket100.types.BlockPosition[] destroyedBlocks;

    this() pure nothrow @safe @nogc {}

    this(Vector!(float, "xyz") position, float radius=float.init, soupply.pocket100.types.BlockPosition[] destroyedBlocks=(soupply.pocket100.types.BlockPosition[]).init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.radius = radius;
        this.destroyedBlocks = destroyedBlocks;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Explode ret = new Explode();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Explode(position: " ~ std.conv.to!string(this.position) ~ ", radius: " ~ std.conv.to!string(this.radius) ~ ", destroyedBlocks: " ~ std.conv.to!string(this.destroyedBlocks) ~ ")";
    }

}

class LevelSoundEvent : Pocket100Packet
{

    enum ubyte ID = 26;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // sound
    enum ubyte ITEM_USE_ON = 0;
    enum ubyte HIT = 1;
    enum ubyte STEP = 2;
    enum ubyte JUMP = 3;
    enum ubyte BREAK = 4;
    enum ubyte PLACE = 5;
    enum ubyte HEAVY_STEP = 6;
    enum ubyte GALLOP = 7;
    enum ubyte FALL = 8;
    enum ubyte AMBIENT = 9;
    enum ubyte AMBIENT_BABY = 10;
    enum ubyte AMBIENT_IN_WATER = 11;
    enum ubyte BREATHE = 12;
    enum ubyte DEATH = 13;
    enum ubyte DEATH_IN_WATER = 14;
    enum ubyte DEATH_TO_ZOMBIE = 15;
    enum ubyte HURT = 16;
    enum ubyte HURT_IN_WATER = 17;
    enum ubyte MAD = 18;
    enum ubyte BOOST = 19;
    enum ubyte BOW = 20;
    enum ubyte SQUISH_BIG = 21;
    enum ubyte SQUISH_SMALL = 22;
    enum ubyte FALL_BIG = 23;
    enum ubyte FALL_SMALL = 24;
    enum ubyte SPLASH = 25;
    enum ubyte FIZZ = 26;
    enum ubyte FLAP = 27;
    enum ubyte SWIM = 28;
    enum ubyte DRINK = 29;
    enum ubyte EAT = 30;
    enum ubyte TAKEOFF = 31;
    enum ubyte SHAKE = 32;
    enum ubyte PLOP = 33;
    enum ubyte LAND = 34;
    enum ubyte SADDLE = 35;
    enum ubyte ARMOR = 36;
    enum ubyte ADD_CHEST = 37;
    enum ubyte THROW = 38;
    enum ubyte ATTACK = 39;
    enum ubyte ATTACK_NODAMAGE = 40;
    enum ubyte WARN = 41;
    enum ubyte SHEAR = 42;
    enum ubyte MILK = 43;
    enum ubyte THUNDER = 44;
    enum ubyte EXPLODE = 45;
    enum ubyte FIRE = 46;
    enum ubyte IGNITE = 47;
    enum ubyte FUSE = 48;
    enum ubyte STARE = 49;
    enum ubyte SPAWN = 50;
    enum ubyte SHOOT = 51;
    enum ubyte BREAK_BLOCK = 52;
    enum ubyte REMEDY = 53;
    enum ubyte UNFECT = 54;
    enum ubyte LEVELUP = 55;
    enum ubyte BOW_HIT = 56;
    enum ubyte BULLET_HIT = 57;
    enum ubyte EXTINGUISH_FIRE = 58;
    enum ubyte ITEM_FIZZ = 59;
    enum ubyte CHEST_OPEN = 60;
    enum ubyte CHEST_CLOSED = 61;
    enum ubyte POWER_ON = 62;
    enum ubyte POWER_OFF = 63;
    enum ubyte ATTACH = 64;
    enum ubyte DETACH = 65;
    enum ubyte DENY = 66;
    enum ubyte TRIPOD = 67;
    enum ubyte POP = 68;
    enum ubyte DROP_SLOT = 69;
    enum ubyte NOTE = 70;
    enum ubyte THORNS = 71;
    enum ubyte PISTON_IN = 72;
    enum ubyte PISTON_OUT = 73;
    enum ubyte PORTAL = 74;
    enum ubyte WATER = 75;
    enum ubyte LAVA_POP = 76;
    enum ubyte LAVA = 77;
    enum ubyte BURP = 78;
    enum ubyte BUCKET_FILL_WATER = 79;
    enum ubyte BUCKET_FILL_LAVA = 80;
    enum ubyte BUCKET_EMPTY_WATER = 81;
    enum ubyte BUCKET_EMPTY_LAVA = 82;
    enum ubyte GUARDIAN_FLOP = 83;
    enum ubyte ELDERGUARDIAN_CURSE = 84;
    enum ubyte MOB_WARNING = 85;
    enum ubyte MOB_WARNING_BABY = 86;
    enum ubyte TELEPORT = 87;
    enum ubyte SHULKER_OPEN = 88;
    enum ubyte SHULKER_CLOSE = 89;
    enum ubyte DEFAULT = 90;
    enum ubyte UNDEFINED = 91;

    enum string[] __fields = ["sound", "position", "volume", "pitch", "unknown4"];

    ubyte sound;
    Vector!(float, "xyz") position;
    @Var uint volume;
    @Var int pitch;
    bool unknown4;

    this() pure nothrow @safe @nogc {}

    this(ubyte sound, Vector!(float, "xyz") position=Vector!(float, "xyz").init, uint volume=uint.init, int pitch=int.init, bool unknown4=bool.init) pure nothrow @safe @nogc
    {
        this.sound = sound;
        this.position = position;
        this.volume = volume;
        this.pitch = pitch;
        this.unknown4 = unknown4;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        LevelSoundEvent ret = new LevelSoundEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "LevelSoundEvent(sound: " ~ std.conv.to!string(this.sound) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
    }

}

class LevelEvent : Pocket100Packet
{

    enum ubyte ID = 27;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // event id
    enum int START_RAIN = 3001;
    enum int START_THUNDER = 3002;
    enum int STOP_RAIN = 3003;
    enum int STOP_THUNDER = 3004;
    enum int SET_DATA = 4000;
    enum int PLAYERS_SLEEPING = 9800;
    enum int BUBBLE = 16385;
    enum int CRITICAL = 16386;
    enum int BLOCK_FORCE_FIELD = 16387;
    enum int SMOKE = 16388;
    enum int EXPLODE = 16389;
    enum int EVAPORATION = 16390;
    enum int FLAME = 16391;
    enum int LAVA = 16392;
    enum int LARGE_SMOKE = 16393;
    enum int REDSTONE = 16394;
    enum int RISING_RED_DUST = 16395;
    enum int ITEM_BREAK = 16396;
    enum int SNOWBALL_POOF = 16397;
    enum int HUGE_EXPLODE = 16398;
    enum int HUGE_EXPLODE_SEED = 16399;
    enum int MOB_FLAME = 16400;
    enum int HEART = 16401;
    enum int TERRAIN = 16402;
    enum int TOWN_AURA = 16403;
    enum int PORTAL = 16404;
    enum int WATER_SPLASH = 16405;
    enum int WATER_WAKE = 16406;
    enum int DRIP_WATER = 16407;
    enum int DRIP_LAVA = 16408;
    enum int FALLING_DUST = 16409;
    enum int MOB_SPELL = 16410;
    enum int MOB_SPELL_AMBIENT = 16411;
    enum int MOB_SPELL_INSTANTANEOUS = 16412;
    enum int INK = 16413;
    enum int SLIME = 16414;
    enum int RAIN_SPLASH = 16415;
    enum int VILLAGER_ANGRY = 16416;
    enum int VILLAGER_HAPPY = 16417;
    enum int ENCHANTMENT_TABLE = 16418;
    enum int TRACKING_EMITTER = 16419;
    enum int NOTE = 16420;
    enum int WITCH_SPELL = 16421;
    enum int CARROT = 16422;
    enum int END_ROD = 16424;
    enum int DRAGON_BREATH = 16425;
    enum int SHOOT = 2000;
    enum int DESTROY = 2001;

    enum string[] __fields = ["eventId", "position", "data"];

    @Var int eventId;
    Vector!(float, "xyz") position;
    @Var int data;

    this() pure nothrow @safe @nogc {}

    this(int eventId, Vector!(float, "xyz") position=Vector!(float, "xyz").init, int data=int.init) pure nothrow @safe @nogc
    {
        this.eventId = eventId;
        this.position = position;
        this.data = data;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        LevelEvent ret = new LevelEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "LevelEvent(eventId: " ~ std.conv.to!string(this.eventId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
    }

}

class BlockEvent : Pocket100Packet
{

    enum ubyte ID = 28;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position", "data"];

    soupply.pocket100.types.BlockPosition position;
    @Var int[2] data;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition position, int[2] data=(int[2]).init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.data = data;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        BlockEvent ret = new BlockEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "BlockEvent(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
    }

}

class EntityEvent : Pocket100Packet
{

    enum ubyte ID = 29;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // event id
    enum ubyte HURT_ANIMATION = 2;
    enum ubyte DEATH_ANIMATION = 3;
    enum ubyte TAME_FAIL = 6;
    enum ubyte TAME_SUCCESS = 7;
    enum ubyte SHAKE_WET = 8;
    enum ubyte USE_ITEM = 9;
    enum ubyte EAT_GRASS_ANIMATION = 10;
    enum ubyte FISH_HOOK_BUBBLES = 11;
    enum ubyte FISH_HOOK_POSITION = 12;
    enum ubyte FISH_HOOK_HOOK = 13;
    enum ubyte FISH_HOOK_TEASE = 14;
    enum ubyte SQUID_INK_CLOUD = 15;
    enum ubyte AMBIENT_SOUND = 16;
    enum ubyte RESPAWN = 17;

    enum string[] __fields = ["entityId", "eventId", "unknown2"];

    @Var long entityId;
    ubyte eventId;
    @Var int unknown2;

    this() pure nothrow @safe @nogc {}

    this(long entityId, ubyte eventId=ubyte.init, int unknown2=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.eventId = eventId;
        this.unknown2 = unknown2;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        EntityEvent ret = new EntityEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "EntityEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
    }

}

class MobEffect : Pocket100Packet
{

    enum ubyte ID = 30;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // event id
    enum ubyte ADD = 1;
    enum ubyte MODIFY = 2;
    enum ubyte REMOVE = 3;

    enum string[] __fields = ["entityId", "eventId", "effect", "amplifier", "particles", "duration"];

    @Var long entityId;
    ubyte eventId;
    @Var int effect;
    @Var int amplifier;
    bool particles;
    @Var int duration;

    this() pure nothrow @safe @nogc {}

    this(long entityId, ubyte eventId=ubyte.init, int effect=int.init, int amplifier=int.init, bool particles=bool.init, int duration=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.eventId = eventId;
        this.effect = effect;
        this.amplifier = amplifier;
        this.particles = particles;
        this.duration = duration;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MobEffect ret = new MobEffect();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MobEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", effect: " ~ std.conv.to!string(this.effect) ~ ", amplifier: " ~ std.conv.to!string(this.amplifier) ~ ", particles: " ~ std.conv.to!string(this.particles) ~ ", duration: " ~ std.conv.to!string(this.duration) ~ ")";
    }

}

class UpdateAttributes : Pocket100Packet
{

    enum ubyte ID = 31;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "attributes"];

    @Var long entityId;
    soupply.pocket100.types.Attribute[] attributes;

    this() pure nothrow @safe @nogc {}

    this(long entityId, soupply.pocket100.types.Attribute[] attributes=(soupply.pocket100.types.Attribute[]).init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.attributes = attributes;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        UpdateAttributes ret = new UpdateAttributes();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "UpdateAttributes(entityId: " ~ std.conv.to!string(this.entityId) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ")";
    }

}

class MobEquipment : Pocket100Packet
{

    enum ubyte ID = 32;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["entityId", "item", "inventorySlot", "hotbarSlot", "unknown4"];

    @Var long entityId;
    soupply.pocket100.types.Slot item;
    ubyte inventorySlot;
    ubyte hotbarSlot;
    ubyte unknown4;

    this() pure nothrow @safe @nogc {}

    this(long entityId, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init, ubyte inventorySlot=ubyte.init, ubyte hotbarSlot=ubyte.init, ubyte unknown4=ubyte.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.item = item;
        this.inventorySlot = inventorySlot;
        this.hotbarSlot = hotbarSlot;
        this.unknown4 = unknown4;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MobEquipment ret = new MobEquipment();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MobEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", inventorySlot: " ~ std.conv.to!string(this.inventorySlot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
    }

}

class MobArmorEquipment : Pocket100Packet
{

    enum ubyte ID = 33;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["entityId", "armor"];

    @Var long entityId;
    soupply.pocket100.types.Slot[4] armor;

    this() pure nothrow @safe @nogc {}

    this(long entityId, soupply.pocket100.types.Slot[4] armor=(soupply.pocket100.types.Slot[4]).init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.armor = armor;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MobArmorEquipment ret = new MobArmorEquipment();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MobArmorEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", armor: " ~ std.conv.to!string(this.armor) ~ ")";
    }

}

class Interact : Pocket100Packet
{

    enum ubyte ID = 34;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    // action
    enum ubyte INTERACT = 1;
    enum ubyte ATTACK = 2;
    enum ubyte LEAVE_VEHICLE = 3;
    enum ubyte HOVER = 4;

    enum string[] __fields = ["action", "target"];

    ubyte action;
    @Var long target;

    this() pure nothrow @safe @nogc {}

    this(ubyte action, long target=long.init) pure nothrow @safe @nogc
    {
        this.action = action;
        this.target = target;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Interact ret = new Interact();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Interact(action: " ~ std.conv.to!string(this.action) ~ ", target: " ~ std.conv.to!string(this.target) ~ ")";
    }

}

class UseItem : Pocket100Packet
{

    enum ubyte ID = 35;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["blockPosition", "hotbarSlot", "face", "facePosition", "position", "slot", "item"];

    soupply.pocket100.types.BlockPosition blockPosition;
    @Var uint hotbarSlot;
    @Var int face;
    Vector!(float, "xyz") facePosition;
    Vector!(float, "xyz") position;
    @Var int slot;
    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition blockPosition, uint hotbarSlot=uint.init, int face=int.init, Vector!(float, "xyz") facePosition=Vector!(float, "xyz").init, Vector!(float, "xyz") position=Vector!(float, "xyz").init, int slot=int.init, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init) pure nothrow @safe @nogc
    {
        this.blockPosition = blockPosition;
        this.hotbarSlot = hotbarSlot;
        this.face = face;
        this.facePosition = facePosition;
        this.position = position;
        this.slot = slot;
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        UseItem ret = new UseItem();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "UseItem(blockPosition: " ~ std.conv.to!string(this.blockPosition) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", face: " ~ std.conv.to!string(this.face) ~ ", facePosition: " ~ std.conv.to!string(this.facePosition) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class PlayerAction : Pocket100Packet
{

    enum ubyte ID = 36;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    // action
    enum int START_BREAK = 0;
    enum int ABORT_BREAK = 1;
    enum int STOP_BREAK = 2;
    enum int RELEASE_ITEM = 5;
    enum int STOP_SLEEPING = 6;
    enum int RESPAWN = 7;
    enum int JUMP = 8;
    enum int START_SPRINT = 9;
    enum int STOP_SPRINT = 10;
    enum int START_SNEAK = 11;
    enum int STOP_SNEAK = 12;
    enum int START_GLIDING = 15;
    enum int STOP_GLIDING = 16;

    enum string[] __fields = ["entityId", "action", "position", "face"];

    @Var long entityId;
    @Var int action;
    soupply.pocket100.types.BlockPosition position;
    @Var int face;

    this() pure nothrow @safe @nogc {}

    this(long entityId, int action=int.init, soupply.pocket100.types.BlockPosition position=soupply.pocket100.types.BlockPosition.init, int face=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.action = action;
        this.position = position;
        this.face = face;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        PlayerAction ret = new PlayerAction();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "PlayerAction(entityId: " ~ std.conv.to!string(this.entityId) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", face: " ~ std.conv.to!string(this.face) ~ ")";
    }

}

class PlayerFall : Pocket100Packet
{

    enum ubyte ID = 37;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["distance"];

    float distance;

    this() pure nothrow @safe @nogc {}

    this(float distance) pure nothrow @safe @nogc
    {
        this.distance = distance;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        PlayerFall ret = new PlayerFall();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "PlayerFall(distance: " ~ std.conv.to!string(this.distance) ~ ")";
    }

}

class HurtArmor : Pocket100Packet
{

    enum ubyte ID = 38;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["unknown0"];

    @Var int unknown0;

    this() pure nothrow @safe @nogc {}

    this(int unknown0) pure nothrow @safe @nogc
    {
        this.unknown0 = unknown0;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        HurtArmor ret = new HurtArmor();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "HurtArmor(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ")";
    }

}

class SetEntityData : Pocket100Packet
{

    enum ubyte ID = 39;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "metadata"];

    @Var long entityId;
    Metadata metadata;

    this() pure nothrow @safe @nogc {}

    this(long entityId, Metadata metadata=Metadata.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.metadata = metadata;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetEntityData ret = new SetEntityData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetEntityData(entityId: " ~ std.conv.to!string(this.entityId) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
    }

}

class SetEntityMotion : Pocket100Packet
{

    enum ubyte ID = 40;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "motion"];

    @Var long entityId;
    Vector!(float, "xyz") motion;

    this() pure nothrow @safe @nogc {}

    this(long entityId, Vector!(float, "xyz") motion=Vector!(float, "xyz").init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.motion = motion;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetEntityMotion ret = new SetEntityMotion();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetEntityMotion(entityId: " ~ std.conv.to!string(this.entityId) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
    }

}

class SetEntityLink : Pocket100Packet
{

    enum ubyte ID = 41;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // action
    enum ubyte ADD = 0;
    enum ubyte RIDE = 1;
    enum ubyte REMOVE = 2;

    enum string[] __fields = ["from", "to", "action"];

    @Var long from;
    @Var long to;
    ubyte action;

    this() pure nothrow @safe @nogc {}

    this(long from, long to=long.init, ubyte action=ubyte.init) pure nothrow @safe @nogc
    {
        this.from = from;
        this.to = to;
        this.action = action;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetEntityLink ret = new SetEntityLink();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetEntityLink(from: " ~ std.conv.to!string(this.from) ~ ", to: " ~ std.conv.to!string(this.to) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
    }

}

class SetHealth : Pocket100Packet
{

    enum ubyte ID = 42;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["health"];

    @Var int health;

    this() pure nothrow @safe @nogc {}

    this(int health) pure nothrow @safe @nogc
    {
        this.health = health;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetHealth ret = new SetHealth();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetHealth(health: " ~ std.conv.to!string(this.health) ~ ")";
    }

}

class SetSpawnPosition : Pocket100Packet
{

    enum ubyte ID = 43;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["unknown0", "position", "unknown2"];

    @Var int unknown0;
    soupply.pocket100.types.BlockPosition position;
    bool unknown2;

    this() pure nothrow @safe @nogc {}

    this(int unknown0, soupply.pocket100.types.BlockPosition position=soupply.pocket100.types.BlockPosition.init, bool unknown2=bool.init) pure nothrow @safe @nogc
    {
        this.unknown0 = unknown0;
        this.position = position;
        this.unknown2 = unknown2;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetSpawnPosition ret = new SetSpawnPosition();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetSpawnPosition(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
    }

}

class Animate : Pocket100Packet
{

    enum ubyte ID = 44;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // action
    enum int BREAKING = 1;
    enum int WAKE_UP = 3;

    enum string[] __fields = ["action", "entityId"];

    @Var int action;
    @Var long entityId;

    this() pure nothrow @safe @nogc {}

    this(int action, long entityId=long.init) pure nothrow @safe @nogc
    {
        this.action = action;
        this.entityId = entityId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Animate ret = new Animate();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Animate(action: " ~ std.conv.to!string(this.action) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
    }

}

class Respawn : Pocket100Packet
{

    enum ubyte ID = 45;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position"];

    Vector!(float, "xyz") position;

    this() pure nothrow @safe @nogc {}

    this(Vector!(float, "xyz") position) pure nothrow @safe @nogc
    {
        this.position = position;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Respawn ret = new Respawn();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Respawn(position: " ~ std.conv.to!string(this.position) ~ ")";
    }

}

class DropItem : Pocket100Packet
{

    enum ubyte ID = 46;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    // action
    enum ubyte DROP = 0;

    enum string[] __fields = ["action", "item"];

    ubyte action;
    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(ubyte action, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init) pure nothrow @safe @nogc
    {
        this.action = action;
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        DropItem ret = new DropItem();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "DropItem(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class InventoryAction : Pocket100Packet
{

    enum ubyte ID = 47;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["action", "item"];

    @Var int action;
    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(int action, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init) pure nothrow @safe @nogc
    {
        this.action = action;
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        InventoryAction ret = new InventoryAction();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "InventoryAction(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class ContainerOpen : Pocket100Packet
{

    enum ubyte ID = 48;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["window", "type", "slotCount", "position", "entityId"];

    ubyte window;
    ubyte type;
    @Var int slotCount;
    soupply.pocket100.types.BlockPosition position;
    @Var long entityId;

    this() pure nothrow @safe @nogc {}

    this(ubyte window, ubyte type=ubyte.init, int slotCount=int.init, soupply.pocket100.types.BlockPosition position=soupply.pocket100.types.BlockPosition.init, long entityId=long.init) pure nothrow @safe @nogc
    {
        this.window = window;
        this.type = type;
        this.slotCount = slotCount;
        this.position = position;
        this.entityId = entityId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ContainerOpen ret = new ContainerOpen();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ContainerOpen(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", slotCount: " ~ std.conv.to!string(this.slotCount) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
    }

}

class ContainerClose : Pocket100Packet
{

    enum ubyte ID = 49;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["window"];

    ubyte window;

    this() pure nothrow @safe @nogc {}

    this(ubyte window) pure nothrow @safe @nogc
    {
        this.window = window;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ContainerClose ret = new ContainerClose();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ContainerClose(window: " ~ std.conv.to!string(this.window) ~ ")";
    }

}

class ContainerSetSlot : Pocket100Packet
{

    enum ubyte ID = 50;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["window", "slot", "hotbarSlot", "item", "unknown4"];

    ubyte window;
    @Var int slot;
    @Var int hotbarSlot;
    soupply.pocket100.types.Slot item;
    ubyte unknown4;

    this() pure nothrow @safe @nogc {}

    this(ubyte window, int slot=int.init, int hotbarSlot=int.init, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init, ubyte unknown4=ubyte.init) pure nothrow @safe @nogc
    {
        this.window = window;
        this.slot = slot;
        this.hotbarSlot = hotbarSlot;
        this.item = item;
        this.unknown4 = unknown4;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ContainerSetSlot ret = new ContainerSetSlot();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ContainerSetSlot(window: " ~ std.conv.to!string(this.window) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
    }

}

class ContainerSetData : Pocket100Packet
{

    enum ubyte ID = 51;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["window", "property", "value"];

    ubyte window;
    @Var int property;
    @Var int value;

    this() pure nothrow @safe @nogc {}

    this(ubyte window, int property=int.init, int value=int.init) pure nothrow @safe @nogc
    {
        this.window = window;
        this.property = property;
        this.value = value;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ContainerSetData ret = new ContainerSetData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ContainerSetData(window: " ~ std.conv.to!string(this.window) ~ ", property: " ~ std.conv.to!string(this.property) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
    }

}

class ContainerSetContent : Pocket100Packet
{

    enum ubyte ID = 52;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["window", "slots", "hotbar"];

    ubyte window;
    soupply.pocket100.types.Slot[] slots;
    @Var int[] hotbar;

    this() pure nothrow @safe @nogc {}

    this(ubyte window, soupply.pocket100.types.Slot[] slots=(soupply.pocket100.types.Slot[]).init, int[] hotbar=(int[]).init) pure nothrow @safe @nogc
    {
        this.window = window;
        this.slots = slots;
        this.hotbar = hotbar;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ContainerSetContent ret = new ContainerSetContent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ContainerSetContent(window: " ~ std.conv.to!string(this.window) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ", hotbar: " ~ std.conv.to!string(this.hotbar) ~ ")";
    }

}

class CraftingData : Pocket100Packet
{

    enum ubyte ID = 53;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["recipes"];

    soupply.pocket100.types.Recipe[] recipes;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.Recipe[] recipes) pure nothrow @safe @nogc
    {
        this.recipes = recipes;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        CraftingData ret = new CraftingData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "CraftingData(recipes: " ~ std.conv.to!string(this.recipes) ~ ")";
    }

}

class CraftingEvent : Pocket100Packet
{

    enum ubyte ID = 54;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["window", "type", "uuid", "input", "output"];

    ubyte window;
    @Var int type;
    UUID uuid;
    soupply.pocket100.types.Slot[] input;
    soupply.pocket100.types.Slot[] output;

    this() pure nothrow @safe @nogc {}

    this(ubyte window, int type=int.init, UUID uuid=UUID.init, soupply.pocket100.types.Slot[] input=(soupply.pocket100.types.Slot[]).init, soupply.pocket100.types.Slot[] output=(soupply.pocket100.types.Slot[]).init) pure nothrow @safe @nogc
    {
        this.window = window;
        this.type = type;
        this.uuid = uuid;
        this.input = input;
        this.output = output;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        CraftingEvent ret = new CraftingEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "CraftingEvent(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
    }

}

class AdventureSettings : Pocket100Packet
{

    enum ubyte ID = 55;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // flags
    enum uint IMMUTABLE_WORLD = 1;
    enum uint PVP_DISABLED = 2;
    enum uint PVM_DISABLED = 4;
    enum uint MVP_DISBALED = 8;
    enum uint EVP_DISABLED = 16;
    enum uint AUTO_JUMP = 32;
    enum uint ALLOW_FLIGHT = 64;
    enum uint NO_CLIP = 128;
    enum uint FLYING = 512;

    // permissions
    enum uint USER = 0;
    enum uint OPERATOR = 1;
    enum uint HOST = 2;
    enum uint AUTOMATION = 3;
    enum uint ADMIN = 4;

    enum string[] __fields = ["flags", "permissions"];

    @Var uint flags;
    @Var uint permissions;

    this() pure nothrow @safe @nogc {}

    this(uint flags, uint permissions=uint.init) pure nothrow @safe @nogc
    {
        this.flags = flags;
        this.permissions = permissions;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AdventureSettings ret = new AdventureSettings();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AdventureSettings(flags: " ~ std.conv.to!string(this.flags) ~ ", permissions: " ~ std.conv.to!string(this.permissions) ~ ")";
    }

}

class BlockEntityData : Pocket100Packet
{

    enum ubyte ID = 56;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["position", "nbt"];

    soupply.pocket100.types.BlockPosition position;
    @Bytes ubyte[] nbt;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition position, ubyte[] nbt=(ubyte[]).init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.nbt = nbt;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        BlockEntityData ret = new BlockEntityData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "BlockEntityData(position: " ~ std.conv.to!string(this.position) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
    }

}

class PlayerInput : Pocket100Packet
{

    enum ubyte ID = 57;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["motion", "flags", "unknown2"];

    Vector!(float, "xyz") motion;
    ubyte flags;
    bool unknown2;

    this() pure nothrow @safe @nogc {}

    this(Vector!(float, "xyz") motion, ubyte flags=ubyte.init, bool unknown2=bool.init) pure nothrow @safe @nogc
    {
        this.motion = motion;
        this.flags = flags;
        this.unknown2 = unknown2;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        PlayerInput ret = new PlayerInput();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "PlayerInput(motion: " ~ std.conv.to!string(this.motion) ~ ", flags: " ~ std.conv.to!string(this.flags) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
    }

}

class FullChunkData : Pocket100Packet
{

    enum ubyte ID = 58;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position", "data"];

    @Var Vector!(int, "xz") position;
    soupply.pocket100.types.ChunkData data;

    this() pure nothrow @safe @nogc {}

    this(Vector!(int, "xz") position, soupply.pocket100.types.ChunkData data=soupply.pocket100.types.ChunkData.init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.data = data;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        FullChunkData ret = new FullChunkData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "FullChunkData(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
    }

}

class SetCommandsEnabled : Pocket100Packet
{

    enum ubyte ID = 59;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["enabled"];

    bool enabled;

    this() pure nothrow @safe @nogc {}

    this(bool enabled) pure nothrow @safe @nogc
    {
        this.enabled = enabled;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetCommandsEnabled ret = new SetCommandsEnabled();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetCommandsEnabled(enabled: " ~ std.conv.to!string(this.enabled) ~ ")";
    }

}

class SetDifficulty : Pocket100Packet
{

    enum ubyte ID = 60;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // difficulty
    enum uint PEACEFUL = 0;
    enum uint EASY = 1;
    enum uint NORMAL = 2;
    enum uint HARD = 3;

    enum string[] __fields = ["difficulty"];

    @Var uint difficulty;

    this() pure nothrow @safe @nogc {}

    this(uint difficulty) pure nothrow @safe @nogc
    {
        this.difficulty = difficulty;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetDifficulty ret = new SetDifficulty();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetDifficulty(difficulty: " ~ std.conv.to!string(this.difficulty) ~ ")";
    }

}

class ChangeDimension : Pocket100Packet
{

    enum ubyte ID = 61;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // dimension
    enum int OVERWORLD = 0;
    enum int NETHER = 1;
    enum int END = 2;

    enum string[] __fields = ["dimension", "position", "unknown2"];

    @Var int dimension;
    Vector!(float, "xyz") position;
    bool unknown2;

    this() pure nothrow @safe @nogc {}

    this(int dimension, Vector!(float, "xyz") position=Vector!(float, "xyz").init, bool unknown2=bool.init) pure nothrow @safe @nogc
    {
        this.dimension = dimension;
        this.position = position;
        this.unknown2 = unknown2;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ChangeDimension ret = new ChangeDimension();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ChangeDimension(dimension: " ~ std.conv.to!string(this.dimension) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
    }

}

class SetPlayerGameType : Pocket100Packet
{

    enum ubyte ID = 62;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // gamemode
    enum int SURVIVAL = 0;
    enum int CREATIVE = 1;

    enum string[] __fields = ["gamemode"];

    @Var int gamemode;

    this() pure nothrow @safe @nogc {}

    this(int gamemode) pure nothrow @safe @nogc
    {
        this.gamemode = gamemode;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SetPlayerGameType ret = new SetPlayerGameType();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SetPlayerGameType(gamemode: " ~ std.conv.to!string(this.gamemode) ~ ")";
    }

}

class PlayerList : Pocket100Packet
{

    enum ubyte ID = 63;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["action"];

    ubyte action;

    this() pure nothrow @safe @nogc {}

    this(ubyte action) pure nothrow @safe @nogc
    {
        this.action = action;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        PlayerList ret = new PlayerList();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "PlayerList(action: " ~ std.conv.to!string(this.action) ~ ")";
    }

    enum string variantField = "action";

    alias Variants = TypeTuple!(Add, Remove);

    class Add : Pocket100Packet
    {

        enum typeof(action) ACTION = 0;

        enum string[] __fields = ["players"];

        soupply.pocket100.types.PlayerList[] players;

        this() pure nothrow @safe @nogc {}

        this(soupply.pocket100.types.PlayerList[] players) pure nothrow @safe @nogc
        {
            this.players = players;
        }

        mixin Make;

        override string toString()
        {
            return "PlayerList.Add(players: " ~ std.conv.to!string(this.players) ~ ")";
        }

    }

    class Remove : Pocket100Packet
    {

        enum typeof(action) ACTION = 1;

        enum string[] __fields = ["players"];

        UUID[] players;

        this() pure nothrow @safe @nogc {}

        this(UUID[] players) pure nothrow @safe @nogc
        {
            this.players = players;
        }

        mixin Make;

        override string toString()
        {
            return "PlayerList.Remove(players: " ~ std.conv.to!string(this.players) ~ ")";
        }

    }

}

class TelemetryEvent : Pocket100Packet
{

    enum ubyte ID = 64;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["entityId", "eventId"];

    @Var long entityId;
    @Var int eventId;

    this() pure nothrow @safe @nogc {}

    this(long entityId, int eventId=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.eventId = eventId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        TelemetryEvent ret = new TelemetryEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "TelemetryEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
    }

}

class SpawnExperienceOrb : Pocket100Packet
{

    enum ubyte ID = 65;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position", "count"];

    Vector!(float, "xyz") position;
    @Var int count;

    this() pure nothrow @safe @nogc {}

    this(Vector!(float, "xyz") position, int count=int.init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.count = count;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        SpawnExperienceOrb ret = new SpawnExperienceOrb();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "SpawnExperienceOrb(position: " ~ std.conv.to!string(this.position) ~ ", count: " ~ std.conv.to!string(this.count) ~ ")";
    }

}

class ClientboundMapItemData : Pocket100Packet
{

    enum ubyte ID = 66;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // update
    enum uint TEXTURE = 2;
    enum uint DECORATIONS = 4;
    enum uint ENTITIES = 8;

    enum string[] __fields = ["mapId", "update", "scale", "size", "offset", "data", "decorations"];

    @Var long mapId;
    @Var uint update;
    @Condition("update==2||update==4") ubyte scale;
    @Condition("update==2") @Var Vector!(int, "xz") size;
    @Condition("update==2") @Var Vector!(int, "xz") offset;
    @Condition("update==2") @Bytes ubyte[] data;
    @Condition("update==4") soupply.pocket100.types.Decoration[] decorations;

    this() pure nothrow @safe @nogc {}

    this(long mapId, uint update=uint.init, ubyte scale=ubyte.init, Vector!(int, "xz") size=Vector!(int, "xz").init, Vector!(int, "xz") offset=Vector!(int, "xz").init, ubyte[] data=(ubyte[]).init, soupply.pocket100.types.Decoration[] decorations=(soupply.pocket100.types.Decoration[]).init) pure nothrow @safe @nogc
    {
        this.mapId = mapId;
        this.update = update;
        this.scale = scale;
        this.size = size;
        this.offset = offset;
        this.data = data;
        this.decorations = decorations;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ClientboundMapItemData ret = new ClientboundMapItemData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ClientboundMapItemData(mapId: " ~ std.conv.to!string(this.mapId) ~ ", update: " ~ std.conv.to!string(this.update) ~ ", scale: " ~ std.conv.to!string(this.scale) ~ ", size: " ~ std.conv.to!string(this.size) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", decorations: " ~ std.conv.to!string(this.decorations) ~ ")";
    }

}

class MapInfoRequest : Pocket100Packet
{

    enum ubyte ID = 67;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["mapId"];

    @Var long mapId;

    this() pure nothrow @safe @nogc {}

    this(long mapId) pure nothrow @safe @nogc
    {
        this.mapId = mapId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        MapInfoRequest ret = new MapInfoRequest();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "MapInfoRequest(mapId: " ~ std.conv.to!string(this.mapId) ~ ")";
    }

}

class RequestChunkRadius : Pocket100Packet
{

    enum ubyte ID = 68;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["radius"];

    @Var int radius;

    this() pure nothrow @safe @nogc {}

    this(int radius) pure nothrow @safe @nogc
    {
        this.radius = radius;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        RequestChunkRadius ret = new RequestChunkRadius();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "RequestChunkRadius(radius: " ~ std.conv.to!string(this.radius) ~ ")";
    }

}

class ChunkRadiusUpdated : Pocket100Packet
{

    enum ubyte ID = 69;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["radius"];

    @Var int radius;

    this() pure nothrow @safe @nogc {}

    this(int radius) pure nothrow @safe @nogc
    {
        this.radius = radius;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ChunkRadiusUpdated ret = new ChunkRadiusUpdated();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ChunkRadiusUpdated(radius: " ~ std.conv.to!string(this.radius) ~ ")";
    }

}

class ItemFrameDropItem : Pocket100Packet
{

    enum ubyte ID = 70;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["position", "item"];

    soupply.pocket100.types.BlockPosition position;
    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.BlockPosition position, soupply.pocket100.types.Slot item=soupply.pocket100.types.Slot.init) pure nothrow @safe @nogc
    {
        this.position = position;
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ItemFrameDropItem ret = new ItemFrameDropItem();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ItemFrameDropItem(position: " ~ std.conv.to!string(this.position) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class ReplaceSelectedItem : Pocket100Packet
{

    enum ubyte ID = 71;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["item"];

    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.Slot item) pure nothrow @safe @nogc
    {
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ReplaceSelectedItem ret = new ReplaceSelectedItem();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ReplaceSelectedItem(item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class GameRulesChanged : Pocket100Packet
{

    enum ubyte ID = 72;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["rules"];

    @Length!uint soupply.pocket100.types.Rule[] rules;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.Rule[] rules) pure nothrow @safe @nogc
    {
        this.rules = rules;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        GameRulesChanged ret = new GameRulesChanged();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "GameRulesChanged(rules: " ~ std.conv.to!string(this.rules) ~ ")";
    }

}

class Camera : Pocket100Packet
{

    enum ubyte ID = 73;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["unknown0", "unknown1"];

    @Var long unknown0;
    @Var long unknown1;

    this() pure nothrow @safe @nogc {}

    this(long unknown0, long unknown1=long.init) pure nothrow @safe @nogc
    {
        this.unknown0 = unknown0;
        this.unknown1 = unknown1;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        Camera ret = new Camera();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "Camera(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
    }

}

class AddItem : Pocket100Packet
{

    enum ubyte ID = 74;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["item"];

    soupply.pocket100.types.Slot item;

    this() pure nothrow @safe @nogc {}

    this(soupply.pocket100.types.Slot item) pure nothrow @safe @nogc
    {
        this.item = item;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AddItem ret = new AddItem();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AddItem(item: " ~ std.conv.to!string(this.item) ~ ")";
    }

}

class BossEvent : Pocket100Packet
{

    enum ubyte ID = 75;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    // event id
    enum uint ADD = 0;
    enum uint UPDATE = 1;
    enum uint REMOVE = 2;

    enum string[] __fields = ["entityId", "eventId"];

    @Var long entityId;
    @Var uint eventId;

    this() pure nothrow @safe @nogc {}

    this(long entityId, uint eventId=uint.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.eventId = eventId;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        BossEvent ret = new BossEvent();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "BossEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
    }

}

class ShowCredits : Pocket100Packet
{

    enum ubyte ID = 76;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = true;

    // status
    enum int START = 0;
    enum int END = 1;

    enum string[] __fields = ["entityId", "status"];

    @Var long entityId;
    @Var int status;

    this() pure nothrow @safe @nogc {}

    this(long entityId, int status=int.init) pure nothrow @safe @nogc
    {
        this.entityId = entityId;
        this.status = status;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ShowCredits ret = new ShowCredits();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ShowCredits(entityId: " ~ std.conv.to!string(this.entityId) ~ ", status: " ~ std.conv.to!string(this.status) ~ ")";
    }

}

class AvailableCommands : Pocket100Packet
{

    enum ubyte ID = 77;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["commands", "unknown1"];

    string commands;
    string unknown1;

    this() pure nothrow @safe @nogc {}

    this(string commands, string unknown1=string.init) pure nothrow @safe @nogc
    {
        this.commands = commands;
        this.unknown1 = unknown1;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        AvailableCommands ret = new AvailableCommands();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "AvailableCommands(commands: " ~ std.conv.to!string(this.commands) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
    }

}

class CommandStep : Pocket100Packet
{

    enum ubyte ID = 78;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["command", "overload", "unknown2", "currentStep", "done", "clientId", "input", "output"];

    string command;
    string overload;
    @Var uint unknown2;
    @Var uint currentStep;
    bool done;
    @Var ulong clientId;
    string input;
    string output;

    this() pure nothrow @safe @nogc {}

    this(string command, string overload=string.init, uint unknown2=uint.init, uint currentStep=uint.init, bool done=bool.init, ulong clientId=ulong.init, string input=string.init, string output=string.init) pure nothrow @safe @nogc
    {
        this.command = command;
        this.overload = overload;
        this.unknown2 = unknown2;
        this.currentStep = currentStep;
        this.done = done;
        this.clientId = clientId;
        this.input = input;
        this.output = output;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        CommandStep ret = new CommandStep();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "CommandStep(command: " ~ std.conv.to!string(this.command) ~ ", overload: " ~ std.conv.to!string(this.overload) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", currentStep: " ~ std.conv.to!string(this.currentStep) ~ ", done: " ~ std.conv.to!string(this.done) ~ ", clientId: " ~ std.conv.to!string(this.clientId) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
    }

}

class ResourcePackDataInfo : Pocket100Packet
{

    enum ubyte ID = 79;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["id", "maxChunkSize", "chunkCount", "compressedPackSize", "sha256"];

    string id;
    @LittleEndian uint maxChunkSize;
    @LittleEndian uint chunkCount;
    @LittleEndian ulong compressedPackSize;
    string sha256;

    this() pure nothrow @safe @nogc {}

    this(string id, uint maxChunkSize=uint.init, uint chunkCount=uint.init, ulong compressedPackSize=ulong.init, string sha256=string.init) pure nothrow @safe @nogc
    {
        this.id = id;
        this.maxChunkSize = maxChunkSize;
        this.chunkCount = chunkCount;
        this.compressedPackSize = compressedPackSize;
        this.sha256 = sha256;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePackDataInfo ret = new ResourcePackDataInfo();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePackDataInfo(id: " ~ std.conv.to!string(this.id) ~ ", maxChunkSize: " ~ std.conv.to!string(this.maxChunkSize) ~ ", chunkCount: " ~ std.conv.to!string(this.chunkCount) ~ ", compressedPackSize: " ~ std.conv.to!string(this.compressedPackSize) ~ ", sha256: " ~ std.conv.to!string(this.sha256) ~ ")";
    }

}

class ResourcePackChunkData : Pocket100Packet
{

    enum ubyte ID = 80;

    enum bool CLIENTBOUND = true;
    enum bool SERVERBOUND = false;

    enum string[] __fields = ["id", "chunkIndex", "progress", "data"];

    string id;
    @LittleEndian uint chunkIndex;
    @LittleEndian ulong progress;
    ubyte[] data;

    this() pure nothrow @safe @nogc {}

    this(string id, uint chunkIndex=uint.init, ulong progress=ulong.init, ubyte[] data=(ubyte[]).init) pure nothrow @safe @nogc
    {
        this.id = id;
        this.chunkIndex = chunkIndex;
        this.progress = progress;
        this.data = data;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePackChunkData ret = new ResourcePackChunkData();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePackChunkData(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ", progress: " ~ std.conv.to!string(this.progress) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
    }

}

class ResourcePackChunkRequest : Pocket100Packet
{

    enum ubyte ID = 81;

    enum bool CLIENTBOUND = false;
    enum bool SERVERBOUND = true;

    enum string[] __fields = ["id", "chunkIndex"];

    string id;
    @LittleEndian uint chunkIndex;

    this() pure nothrow @safe @nogc {}

    this(string id, uint chunkIndex=uint.init) pure nothrow @safe @nogc
    {
        this.id = id;
        this.chunkIndex = chunkIndex;
    }

    mixin Make;

    public static typeof(this) fromBuffer(ubyte[] buffer)
    {
        ResourcePackChunkRequest ret = new ResourcePackChunkRequest();
        ret.autoDecode(buffer);
        return ret;
    }

    override string toString()
    {
        return "ResourcePackChunkRequest(id: " ~ std.conv.to!string(this.id) ~ ", chunkIndex: " ~ std.conv.to!string(this.chunkIndex) ~ ")";
    }

}
